---
title: FAQ
excerpt: Explore common questions about Effect, including type extraction, sync/async behavior, comparison with fp-ts, understanding flatMap, and the absence of ZIO-like type aliases. Learn about configuring layers and the flexibility of accepting arguments to influence service construction in layers.
bottomNavigation: pagination
---

## Effect

**Q: Is it possible to extract the types from an Effect?**

A: By using the utility types `Effect.Effect.Context`, `Effect.Effect.Error`, and `Effect.Effect.Success`, we can extract the corresponding types from the `program` Effect. In this example, we extract the context type (`R`), the error type (`E`), and the success type (`A`).

```ts twoslash
import { Effect, Context } from "effect"

class Random extends Context.Tag("Random")<
  Random,
  {
    readonly next: Effect.Effect<number>
  }
>() {}

declare const program: Effect.Effect<number, string, Random>

// type R = Random
type R = Effect.Effect.Context<typeof program>

// type E = string
type E = Effect.Effect.Error<typeof program>

// type A = number
type A = Effect.Effect.Success<typeof program>
```

**Q: Is there a way to determine whether an Effect is synchronous or asynchronous in advance?**

A: No, there isn't a straightforward way to statically determine if an Effect is synchronous or asynchronous. We did explore this idea in earlier versions of Effect, but we decided against it for a few important reasons:

1. **Complexity:** Introducing this feature to track sync/async behavior in the type system would make Effect more complex to use and limit its composability.

2. **Safety Concerns:** We experimented with different approaches to track asynchronous Effects, but they all resulted in a worse developer experience without significantly improving safety. Even with fully synchronous types, we needed to support a `fromCallback` combinator to work with APIs using Continuation-Passing Style (CPS). However, at the type level, it's impossible to guarantee that such a function is always called immediately and not deferred.

In practice, it's important to note that you should typically only run Effects at the edges of your application. If your application is entirely based on Effect, it usually involves a single call to the `main` effect. In such cases, the best approach is to use `runPromise` or `runFork` for most executions. Synchronous execution is a special case and should be considered an edge case, used only when asynchronous execution is not possible. So, our recommendation is to use `runPromise` or `runFork` whenever you can and resort to `runSync` only when absolutely necessary.

**Q: I'm familiar with `flatMap` in JavaScript/TypeScript from its usage on the `Array` prototype. Why do I see it in modules provided by Effect?**

A: Many JavaScript / TypeScript engineers are familiar with the term `flatMap` due to it's [presence as a method on the `Array` prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap). Therefore it may be confusing to see `flatMap` methods exported from many of the modules that Effect provides.

The `flatMap` operation can actually be used to describe a more generic data transformation. Let's consider for a moment a generic data type that we will call `F`. `F` will also be a container for elements, so we can further refine our representation of `F` to `F<A>` which states that `F` holds some information about some data of type `A`.

If we have an `F<A>` and we want to transform to an `F<B>`, we could use the `map` operation:

```ts
map: <A, B>(fa: F<A>, f: (a: A) => B) => F<B>
```

But what if we have some function that returns an `F<B>` instead of just `B`? We can't use `map` because we would end up with a `F<F<B>>` instead of an `F<B>`. What we really want is some operator that allows us to `map` the data and then `flatten` the result.

This exact situation describes a `flatMap` operation:

```ts
flatMap: <A, B>(fa: F<A>, f: (a: A) => F<B>) => F<B>
```

You can also see how this directly applies to `Array`'s `flatMap` if we replace our generic data type `F` with the concrete data type of `Array`:

```ts
flatMap: <A, B>(fa: Array<A>, f: (a: A) => Array<B>) => Array<B>
```

**Q: I can't seem to find any type aliases for Effect. Do any exist? I'm looking for something similar to ZIO's `UIO` / `URIO` / `RIO` / `Task` / `IO`. If not, have you considered adding them?**

A: In Effect, there are no predefined type aliases such as `UIO`, `URIO`, `RIO`, `Task`, or `IO` like in ZIO.

The reason for this is that type aliases are lost as soon as you compose them, which renders them somewhat useless unless you maintain **multiple** signatures for **every** function. In Effect, we have chosen not to go down this path. Instead, we utilize the `never` type to indicate unused types.

It's worth mentioning that the perception of type aliases being quicker to understand is often just an illusion. In Effect, the explicit notation `Effect<A>` clearly communicates that only type `A` is being used. On the other hand, when using a type alias like `RIO<R, A>`, questions arise about the type `E`. Is it `unknown`? `never`? Remembering such details becomes challenging.

## Comparison with fp-ts

**Q: What are the main differences between Effect and [fp-ts](https://github.com/gcanti/fp-ts)?**

A: The main differences between Effect and fp-ts are:

- Effect offers more flexible and powerful dependency management.
- Effect provides built-in services like `Clock`, `Random`, and `Tracer`, which fp-ts lacks.
- Effect includes dedicated testing tools like `TestClock`, while fp-ts does not offer specific testing utilities.
- Effect supports interruptions for canceling computations, whereas fp-ts does not have built-in interruption support.
- Effect has built-in tools to handle defects and unexpected failures, while fp-ts lacks specific defect management features.
- Effect leverages fiber-based concurrency for efficient and lightweight concurrent computations, which fp-ts does not provide.
- Effect includes built-in support for customizable retrying of computations, while fp-ts does not have this feature.
- Effect offers built-in logging, scheduling, caching, and more, which fp-ts does not provide.

For a more detailed comparison, you can refer to the [Effect vs fp-ts](fp-ts) documentation.

### Bundle Size Comparison Between Effect and fp-ts

**Q: I compared the bundle sizes of two simple programs using Effect and fp-ts. Why does Effect have a larger bundle size?**

A: It's natural to observe different bundle sizes because Effect and fp-ts are distinct systems designed for different purposes.
Effect's bundle size is larger due to its included fiber runtime, which is crucial for its functionality.
While the initial bundle size may seem large, the overhead amortizes as you use Effect.

**Q: Should I be concerned about the bundle size difference when choosing between Effect and fp-ts?**

A: Not necessarily. Consider the specific requirements and benefits of each library for your project.
