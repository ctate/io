---
title: Importing Effect
excerpt: Start using Effect by installing the `effect` package and exploring module imports. Learn how to import the `Effect` module, understand namespace imports, and grasp the advantages of using functions over methods in the Effect ecosystem. Focus on essential functions to build a strong foundation for your journey with Effect.
bottomNavigation: pagination
---

Welcome to Effect! If you're just getting started, you might feel overwhelmed by the variety of modules and functions that Effect offers.
However, rest assured that you don't need to worry about all of them right away.
In this guide, we will provide you with a simple orientation on how to import modules and functions and assure you that,
in most cases, installing the `effect` package is all you need to get started. Let's dive in!

## Installing Effect

To begin your journey with Effect, you first need to install the `effect` package. Open your terminal and run the following command:

<Tabs items={["npm", "pnpm", "yarn"]}>
<Tab>

```bash filename="Terminal"
npm install effect
```

</Tab>
<Tab>

```bash filename="Terminal"
pnpm add effect
```

</Tab>
<Tab>

```bash filename="Terminal"
yarn add effect
```

</Tab>
</Tabs>

By installing this single package, you gain access to the core functionality of Effect.

For more detailed installation instructions on other platforms like Deno or Bun, you can refer to the [Quickstart](../../quickstart) tutorial.
This will provide you with step-by-step guidance to set up Effect on different environments.

## Importing Modules and Functions

Once you have installed the `effect` package, you can start using its modules and functions in your projects.
Importing modules and functions is straightforward and follows the standard JavaScript/TypeScript import syntax.

To import a module or a function from the `effect` package, simply use the `import` statement at the top of your file. Here's how you can import the `Effect` module:

```ts
import { Effect } from "effect"
```

Now, you have access to the `Effect` module, which is the heart of the Effect library. It provides various functions to create, compose, and manipulate effectful computations.

## Namespace imports

In addition to importing the `Effect` module with a named import, as shown previously:

```ts
import { Effect } from "effect"
```

You can also import it using a namespace import like this:

```ts
import * as Effect from "effect/Effect"
```

Both forms of import allow you to access the functionalities provided by the `Effect` module.

However an important consideration is **tree shaking**, which refers to a process that eliminates unused code during the bundling of your application.
Named imports may generate tree shaking issues when a bundler doesn't support deep scope analysis.

Here are some bundlers that support deep scope analysis and thus don't have issues with named imports:

- Rollup
- Webpack 5+

## Functions vs Methods

In the Effect ecosystem, libraries often expose functions rather than methods. This design choice is important for two key reasons: tree shakeability and extendibility.

### Tree Shakeability

Tree shakeability refers to the ability of a build system to eliminate unused code during the bundling process. Functions are tree shakeable, while methods are not.

When functions are used in the Effect ecosystem, only the functions that are actually imported and used in your application will be included in the final bundled code. Unused functions are automatically removed, resulting in a smaller bundle size and improved performance.

On the other hand, methods are attached to objects or prototypes, and they cannot be easily tree shaken. Even if you only use a subset of methods, all methods associated with an object or prototype will be included in the bundle, leading to unnecessary code bloat.

### Extendibility

Another important advantage of using functions in the Effect ecosystem is the ease of extendibility. With methods, extending the functionality of an existing API often requires modifying the prototype of the object, which can be complex and error-prone.

In contrast, with functions, extending the functionality is much simpler. You can define your own "extension methods" as plain old functions without the need to modify the prototypes of objects. This promotes cleaner and more modular code, and it also allows for better compatibility with other libraries and modules.

<Idea>
  The use of functions in the Effect ecosystem libraries is important for
  achieving **tree shakeability** and ensuring **extendibility**. Functions
  enable efficient bundling by eliminating unused code, and they provide a
  flexible and modular approach to extending the libraries' functionality.
</Idea>

## Commonly Used Functions

As you start your adventure with Effect, you don't need to dive into every function in the `effect` package right away. Instead, focus on some commonly used functions that will provide a solid foundation for your journey into the world of Effect.

In the upcoming guides, we will explore some of these essential functions, specifically those for creating and running `Effect`s and building pipelines.

But before we dive into those, let's start from the very heart of Effect: understanding the `Effect` type. This will lay the groundwork for your understanding of how Effect brings composability, type safety, and error handling into your applications.

So, let's take the first step and explore the fundamental concepts of the [The Effect Type](the-effect-type).
